// =============================================================================
// FlowTrack Database Schema
// =============================================================================
// Generated: 2025-01-22
// Database: PostgreSQL
// ORM: Prisma
// Total Models: 26
// =============================================================================

generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["postgresqlExtensions"]
}

datasource db {
  provider   = "postgresql"
  url        = env("DATABASE_URL")
  extensions = [citext]
}

// =============================================================================
// ENUMS
// =============================================================================

enum WorkspaceMemberRole {
  owner
  admin
  member
  viewer

  @@map("workspace_member_role")
}

enum OAuthProviderType {
  GOOGLE_EMAIL
  OUTLOOK_EMAIL
  CALENDLY

  @@map("oauth_provider_type")
}

enum BookingStatus {
  scheduled
  canceled
  rescheduled
  completed
  no_show

  @@map("booking_status")
}

enum BookingAttributionMethod {
  UTM
  HIDDEN_FIELD
  MANUAL

  @@map("booking_attribution_method")
}

enum BookingReceivedVia {
  WEBHOOK
  POLLING
  MANUAL

  @@map("booking_received_via")
}

enum PollingJobStatus {
  RUNNING
  COMPLETED
  FAILED
  TIMEOUT

  @@map("polling_job_status")
}

enum WorkflowStatus {
  draft
  active
  paused
  archived

  @@map("workflow_status")
}

enum NodeCategory {
  trigger
  action
  logic
  utility

  @@map("node_category")
}

enum FieldType {
  TEXT
  EMAIL
  TEXTAREA
  DROPDOWN
  NUMBER
  DATE
  CHECKBOX

  @@map("field_type")
}

enum LeadSource {
  FORM
  EMAIL_FORWARD
  API
  MANUAL
  IMPORT

  @@map("lead_source")
}

enum LeadStatus {
  NEW // Initial status when lead is created
  EMAIL_SENT // Email has been sent to lead
  EMAIL_OPENED // Lead opened the email (tracking)
  FOLLOW_UP_PENDING // Follow-up email needs to be sent
  FOLLOW_UP_SENT // Follow-up email was sent
  RESPONDED // Lead responded to outreach
  BOOKED // Meeting/call booked
  WON // Successfully onboarded as client
  LOST // Lead is lost/unresponsive
  DISQUALIFIED // Lead doesn't meet criteria

  @@map("lead_status")
}

enum EnrichmentStatus {
  PENDING // Enrichment queued but not started
  PROCESSING // Currently enriching
  COMPLETED // Enrichment successful
  FAILED // Enrichment failed
  SKIPPED // Enrichment skipped (no domain/invalid email)

  @@map("enrichment_status")
}

enum LeadEventCategory {
  activity
  system
  communication
  automation

  @@map("lead_event_category")
}

enum WorkflowExecutionStatus {
  queued
  running
  completed
  failed
  cancelled
  paused

  @@map("workflow_execution_status")
}

enum ExecutionStepStatus {
  pending
  running
  completed
  failed
  skipped

  @@map("execution_step_status")
}

enum LogLevel {
  DEBUG
  INFO
  WARN
  ERROR

  @@map("log_level")
}

enum SubscriptionStatus {
  trial
  active
  past_due
  cancelled
  expired

  @@map("subscription_status")
}

enum BillingCycle {
  monthly
  yearly

  @@map("billing_cycle")
}

enum UsageEventCategory {
  compute
  communication
  storage
  api

  @@map("usage_event_category")
}

enum WebhookDeliveryStatus {
  pending
  delivered
  failed
  cancelled

  @@map("webhook_delivery_status")
}

enum AuthProvider {
  clerk
  local
  google

  @@map("auth_provider")
}

enum MessageDirection {
  INBOUND
  OUTBOUND

  @@map("message_direction")
}

enum EmailTrackingClassification {
  BOT_PREFETCH
  GENUINE_OPEN
  AMBIGUOUS
  DIRECT_OPEN

  @@map("email_tracking_classification")
}

// =============================================================================
// MODULE 1: IDENTITY & ACCESS MANAGEMENT
// =============================================================================

/// Core user identity supporting both Clerk and native authentication
model User {
  id                      String       @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  clerkUserId             String?      @unique @map("clerk_user_id") @db.VarChar(255)
  googleId                String?      @unique @map("google_id") @db.VarChar(255)
  email                   String       @unique @db.Citext
  firstName               String?      @map("first_name") @db.VarChar(100)
  lastName                String?      @map("last_name") @db.VarChar(100)
  avatarUrl               String?      @map("avatar_url") @db.Text
  authProvider            AuthProvider @default(local) @map("auth_provider")
  passwordHash            String?      @map("password_hash") @db.VarChar(255)
  passwordChangedAt       DateTime?    @map("password_changed_at") @db.Timestamp()
  emailVerificationToken  String?      @unique @map("email_verification_token") @db.VarChar(255)
  emailVerificationExpiry DateTime?    @map("email_verification_expiry") @db.Timestamp()
  isActive                Boolean      @default(true) @map("is_active")
  emailVerifiedAt         DateTime?    @map("email_verified_at") @db.Timestamp()
  deletedAt               DateTime?    @map("deleted_at") @db.Timestamp()
  createdAt               DateTime     @default(now()) @map("created_at") @db.Timestamp()
  updatedAt               DateTime     @updatedAt @map("updated_at") @db.Timestamp()

  hasCompletedOnboarding Boolean   @default(false) @map("has_completed_onboarding")
  onboardingCompletedAt  DateTime? @map("onboarding_completed_at") @db.Timestamp()

  // Relations
  ownedWorkspaces      Workspace[]
  workspaceMemberships WorkspaceMember[]
  invitedMemberships   WorkspaceMember[]    @relation("InvitedBy")
  triggeredLeadEvents  LeadEvent[]
  passwordResetTokens  PasswordResetToken[]
  refreshTokens        RefreshToken[]
  onboardingSessions   OnboardingSession[]
  oauthCredentials     OAuthCredential[]

  @@index([clerkUserId], map: "idx_users_clerk_id") // TODO: Add partial index WHERE deleted_at IS NULL in migration
  @@index([email], map: "idx_users_email") // TODO: Add partial index WHERE deleted_at IS NULL in migration
  @@index([emailVerificationToken], map: "idx_users_email_verification_token") // TODO: Add partial index WHERE email_verification_token IS NOT NULL in migration
  @@index([authProvider], map: "idx_users_auth_provider")
  @@map("users")
}

/// Multi-tenant workspace container for all user data
model Workspace {
  id            String    @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  name          String    @db.VarChar(100)
  slug          String    @unique @db.VarChar(50)
  intakeEmailId String    @unique @map("intake_email_id") @db.VarChar(50)
  ownerUserId   String    @map("owner_user_id") @db.Uuid
  timezone      String    @default("UTC") @db.VarChar(50)
  settings      Json      @default("{}") @db.JsonB
  isActive      Boolean   @default(true) @map("is_active")
  deletedAt     DateTime? @map("deleted_at") @db.Timestamp()
  createdAt     DateTime  @default(now()) @map("created_at") @db.Timestamp()
  updatedAt     DateTime  @updatedAt @map("updated_at") @db.Timestamp()

  // Relations
  owner               User                 @relation(fields: [ownerUserId], references: [id], onDelete: Restrict)
  members             WorkspaceMember[]
  projects            Project[]
  oauthCredentials    OAuthCredential[]
  workflows           Workflow[]
  leads               Lead[]
  workflowExecutions  WorkflowExecution[]
  usageQuotas         UsageQuota[]
  usageEvents         UsageEvent[]
  webhookEndpoints    WebhookEndpoint[]
  workspaceDailyStats WorkspaceDailyStat[]
  workflowDailyStats  WorkflowDailyStat[]
  subscriptions       Subscription[]
  onboardingSessions  OnboardingSession[]
  bookings            Booking[]
  sentEmails          SentEmail[]
  emailTrackingEvents EmailTrackingEvent[]
  messages            Message[]
  meetingRecordings   MeetingRecording[]

  @@index([ownerUserId], map: "idx_workspaces_owner") // TODO: Add partial index WHERE deleted_at IS NULL in migration)
  @@index([slug], map: "idx_workspaces_slug") // TODO: Add partial index WHERE deleted_at IS NULL in migration)
  @@index([intakeEmailId], map: "idx_workspaces_intake_email")
  @@map("workspaces")
}

/// Team membership for multi-user workspaces
model WorkspaceMember {
  id              String              @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  workspaceId     String              @map("workspace_id") @db.Uuid
  userId          String              @map("user_id") @db.Uuid
  role            WorkspaceMemberRole @default(member)
  permissions     Json                @default("{}") @db.JsonB
  invitedByUserId String?             @map("invited_by_user_id") @db.Uuid
  invitedAt       DateTime?           @map("invited_at") @db.Timestamp()
  joinedAt        DateTime?           @map("joined_at") @db.Timestamp()
  isActive        Boolean             @default(true) @map("is_active")
  deletedAt       DateTime?           @map("deleted_at") @db.Timestamp()
  createdAt       DateTime            @default(now()) @map("created_at") @db.Timestamp()
  updatedAt       DateTime            @updatedAt @map("updated_at") @db.Timestamp()

  // Relations
  workspace Workspace @relation(fields: [workspaceId], references: [id], onDelete: Cascade)
  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  invitedBy User?     @relation("InvitedBy", fields: [invitedByUserId], references: [id])

  @@unique([workspaceId, userId], map: "workspace_members_unique_user_workspace")
  @@index([workspaceId], map: "idx_workspace_members_workspace") // TODO: Add partial index WHERE deleted_at IS NULL in migration)
  @@index([userId], map: "idx_workspace_members_user") // TODO: Add partial index WHERE deleted_at IS NULL in migration)
  @@map("workspace_members")
}

/// Project model for workspace project management
model Project {
  id          String    @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  workspaceId String    @map("workspace_id") @db.Uuid
  name        String    @db.VarChar(150)
  description String?   @db.Text
  deletedAt   DateTime? @map("deleted_at") @db.Timestamp()
  createdAt   DateTime  @default(now()) @map("created_at") @db.Timestamp()
  updatedAt   DateTime  @updatedAt @map("updated_at") @db.Timestamp()

  // Relations
  workspace Workspace @relation(fields: [workspaceId], references: [id], onDelete: Cascade)
  tasks     Task[]

  @@index([workspaceId], map: "idx_projects_workspace") // TODO: Add partial index WHERE deleted_at IS NULL in migration)
  @@map("projects")
}

/// Task model for project task management
model Task {
  id          String    @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  projectId   String    @map("project_id") @db.Uuid
  title       String    @db.VarChar(200)
  description String?   @db.Text
  isComplete  Boolean   @default(false) @map("is_complete")
  deletedAt   DateTime? @map("deleted_at") @db.Timestamp()
  createdAt   DateTime  @default(now()) @map("created_at") @db.Timestamp()
  updatedAt   DateTime  @updatedAt @map("updated_at") @db.Timestamp()

  // Relations
  project Project @relation(fields: [projectId], references: [id], onDelete: Cascade)

  @@index([projectId], map: "idx_tasks_project") // TODO: Add partial index WHERE deleted_at IS NULL in migration)
  @@map("tasks")
}

/// Store encrypted OAuth tokens for third-party integrations
model OAuthCredential {
  id                    String            @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  userId                String            @map("user_id") @db.Uuid
  workspaceId           String?           @map("workspace_id") @db.Uuid
  providerType          OAuthProviderType @map("provider_type")
  providerPlan          String?           @map("provider_plan") @db.VarChar(20) // 'FREE' | 'PRO' | 'ENTERPRISE'
  providerUserId        String?           @map("provider_user_id") @db.VarChar(255)
  providerEmail         String?           @map("provider_email") @db.Citext
  accessToken           String            @map("access_token") @db.Text
  refreshToken          String?           @map("refresh_token") @db.Text
  tokenType             String            @default("Bearer") @map("token_type") @db.VarChar(20)
  expiresAt             DateTime?         @map("expires_at") @db.Timestamp()
  scope                 String?           @db.Text
  metadata              Json              @default("{}") @db.JsonB
  // Webhook-related fields
  webhookUrl            String?           @map("webhook_url") @db.Text
  webhookSigningKey     String?           @map("webhook_signing_key") @db.Text
  webhookEnabled        Boolean           @default(false) @map("webhook_enabled")
  webhookLastVerifiedAt DateTime?         @map("webhook_last_verified_at") @db.Timestamp()
  webhookFailedAttempts Int               @default(0) @map("webhook_failed_attempts")
  // Polling-related fields
  pollingEnabled        Boolean           @default(false) @map("polling_enabled")
  pollingLastRunAt      DateTime?         @map("polling_last_run_at") @db.Timestamp()
  pollingCursor         String?           @map("polling_cursor") @db.Text
  // Rate limiting
  apiRateLimitRemaining Int?              @map("api_rate_limit_remaining")
  apiRateLimitResetAt   DateTime?         @map("api_rate_limit_reset_at") @db.Timestamp()
  // Status
  isActive              Boolean           @default(true) @map("is_active")
  lastUsedAt            DateTime?         @map("last_used_at") @db.Timestamp()
  lastSyncedAt          DateTime?         @map("last_synced_at") @db.Timestamp()
  deletedAt             DateTime?         @map("deleted_at") @db.Timestamp()
  createdAt             DateTime          @default(now()) @map("created_at") @db.Timestamp()
  updatedAt             DateTime          @updatedAt @map("updated_at") @db.Timestamp()

  // Relations
  user        User                @relation(fields: [userId], references: [id], onDelete: Cascade)
  workspace   Workspace?          @relation(fields: [workspaceId], references: [id], onDelete: Cascade)
  bookings    Booking[]
  pollingJobs BookingPollingJob[]

  @@unique([userId, providerType], map: "oauth_credentials_unique_user_provider")
  @@index([userId], map: "idx_oauth_credentials_user") // TODO: Add partial index WHERE deleted_at IS NULL in migration)
  @@index([workspaceId], map: "idx_oauth_credentials_workspace") // TODO: Add partial index WHERE deleted_at IS NULL in migration)
  @@index([providerType, providerEmail], map: "idx_oauth_credentials_provider") // TODO: Add partial index WHERE deleted_at IS NULL in migration)
  @@index([expiresAt], map: "idx_oauth_credentials_expiry") // TODO: Add partial index WHERE is_active = true in migration)
  @@index([providerType, pollingEnabled], map: "idx_oauth_credentials_polling") // TODO: Add partial index WHERE polling_enabled = true in migration)
  @@map("oauth_credentials")
}

// =============================================================================
// MODULE 2: WORKFLOW ORCHESTRATION
// =============================================================================

/// Top-level automation workflow container
model Workflow {
  id                   String         @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  workspaceId          String         @map("workspace_id") @db.Uuid
  name                 String         @db.VarChar(150)
  description          String?        @db.Text
  templateId           String?        @map("template_id") @db.VarChar(100)
  templateVersion      Int?           @map("template_version")
  strategyId           String?        @map("strategy_id") @db.VarChar(100)
  configurationData    Json?          @map("configuration_data") @db.JsonB
  bookingUrl           String?        @map("booking_url") @db.Text
  schedulingType       String?        @map("scheduling_type") @db.VarChar(20) // 'CALENDLY' | 'GOOGLE_MEET'
  status               WorkflowStatus @default(draft)
  version              Int            @default(1)
  settings             Json           @default("{}") @db.JsonB
  // Form header and description fields
  formHeader           String?        @map("form_header") @db.Text
  formHeaderRich       Json?          @map("form_header_rich") @db.JsonB
  formDescription      String?        @map("form_description") @db.Text
  formDescriptionRich  Json?          @map("form_description_rich") @db.JsonB
  showFormHeader       Boolean        @default(true) @map("show_form_header")
  showFormDescription  Boolean        @default(true) @map("show_form_description")
  totalExecutions      Int            @default(0) @map("total_executions")
  successfulExecutions Int            @default(0) @map("successful_executions")
  failedExecutions     Int            @default(0) @map("failed_executions")
  lastExecutedAt       DateTime?      @map("last_executed_at") @db.Timestamp()
  deletedAt            DateTime?      @map("deleted_at") @db.Timestamp()
  createdAt            DateTime       @default(now()) @map("created_at") @db.Timestamp()
  updatedAt            DateTime       @updatedAt @map("updated_at") @db.Timestamp()

  // Relations
  workspace          Workspace           @relation(fields: [workspaceId], references: [id], onDelete: Cascade)
  nodes              WorkflowNode[]
  edges              WorkflowEdge[]
  formFields         FormField[]
  leads              Lead[]
  workflowExecutions WorkflowExecution[]
  bookings           Booking[]
  dailyStats         WorkflowDailyStat[]
  sentEmails         SentEmail[]

  @@index([workspaceId, status], map: "idx_workflows_workspace") // TODO: Add partial index WHERE deleted_at IS NULL in migration)
  @@index([status], map: "idx_workflows_status") // TODO: Add partial index WHERE deleted_at IS NULL in migration)
  @@index([templateId, templateVersion], map: "idx_workflows_template")
  @@index([formHeaderRich(ops: JsonbPathOps)], type: Gin, map: "idx_workflows_form_header_rich")
  @@index([formDescriptionRich(ops: JsonbPathOps)], type: Gin, map: "idx_workflows_form_description_rich")
  @@map("workflows")
}

/// Individual nodes in the workflow graph (React Flow nodes)
model WorkflowNode {
  id              String       @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  workflowId      String       @map("workflow_id") @db.Uuid
  reactFlowNodeId String       @map("react_flow_node_id") @db.VarChar(100)
  nodeType        String       @map("node_type") @db.VarChar(50)
  nodeCategory    NodeCategory @map("node_category")
  positionX       Decimal      @default(0) @map("position_x") @db.Decimal(10, 2)
  positionY       Decimal      @default(0) @map("position_y") @db.Decimal(10, 2)
  config          Json         @default("{}") @db.JsonB
  isEnabled       Boolean      @default(true) @map("is_enabled")
  executionOrder  Int?         @map("execution_order")
  deletedAt       DateTime?    @map("deleted_at") @db.Timestamp()
  createdAt       DateTime     @default(now()) @map("created_at") @db.Timestamp()
  updatedAt       DateTime     @updatedAt @map("updated_at") @db.Timestamp()

  // Relations
  workflow                    Workflow            @relation(fields: [workflowId], references: [id], onDelete: Cascade)
  executionSteps              ExecutionStep[]
  triggeredWorkflowExecutions WorkflowExecution[]

  @@unique([workflowId, reactFlowNodeId], map: "workflow_nodes_unique_react_flow_id")
  @@index([workflowId], map: "idx_workflow_nodes_workflow") // TODO: Add partial index WHERE deleted_at IS NULL in migration)
  @@index([nodeType], map: "idx_workflow_nodes_type")
  @@index([nodeCategory], map: "idx_workflow_nodes_category")
  @@index([config(ops: JsonbPathOps)], type: Gin, map: "idx_workflow_nodes_config")
  @@map("workflow_nodes")
}

/// Connections between workflow nodes (directed graph edges)
model WorkflowEdge {
  id              String    @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  workflowId      String    @map("workflow_id") @db.Uuid
  reactFlowEdgeId String    @map("react_flow_edge_id") @db.VarChar(100)
  sourceNodeId    String    @map("source_node_id") @db.VarChar(100)
  targetNodeId    String    @map("target_node_id") @db.VarChar(100)
  sourceHandle    String?   @map("source_handle") @db.VarChar(50)
  targetHandle    String?   @map("target_handle") @db.VarChar(50)
  edgeType        String    @default("default") @map("edge_type") @db.VarChar(20)
  label           String?   @db.VarChar(100)
  condition       Json?     @db.JsonB
  isEnabled       Boolean   @default(true) @map("is_enabled")
  deletedAt       DateTime? @map("deleted_at") @db.Timestamp()
  createdAt       DateTime  @default(now()) @map("created_at") @db.Timestamp()
  updatedAt       DateTime  @updatedAt @map("updated_at") @db.Timestamp()

  // Relations
  workflow Workflow @relation(fields: [workflowId], references: [id], onDelete: Cascade)

  @@unique([workflowId, sourceNodeId, targetNodeId, sourceHandle, targetHandle], map: "workflow_edges_unique_connection")
  @@index([workflowId], map: "idx_workflow_edges_workflow") // TODO: Add partial index WHERE deleted_at IS NULL in migration)
  @@index([sourceNodeId], map: "idx_workflow_edges_source")
  @@index([targetNodeId], map: "idx_workflow_edges_target")
  @@index([condition(ops: JsonbPathOps)], type: Gin, map: "idx_workflow_edges_condition")
  @@map("workflow_edges")
}

/// Public intake form field definitions
model FormField {
  id              String    @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  workflowId      String    @map("workflow_id") @db.Uuid
  fieldKey        String    @map("field_key") @db.VarChar(50)
  label           String    @db.VarChar(150)
  fieldType       FieldType @map("field_type")
  options         Json?     @db.JsonB
  placeholder     String?   @db.VarChar(255)
  helpText        String?   @map("help_text") @db.Text
  isRequired      Boolean   @default(true) @map("is_required")
  validationRules Json?     @map("validation_rules") @db.JsonB
  displayOrder    Int       @default(0) @map("display_order")
  isActive        Boolean   @default(true) @map("is_active")
  deletedAt       DateTime? @map("deleted_at") @db.Timestamp()
  createdAt       DateTime  @default(now()) @map("created_at") @db.Timestamp()
  updatedAt       DateTime  @updatedAt @map("updated_at") @db.Timestamp()

  // Relations
  workflow      Workflow        @relation(fields: [workflowId], references: [id], onDelete: Cascade)
  leadFieldData LeadFieldData[]

  @@unique([workflowId, fieldKey], map: "form_fields_unique_key_per_workflow")
  @@index([workflowId, displayOrder], map: "idx_form_fields_workflow") // TODO: Add partial index WHERE deleted_at IS NULL in migration)
  @@map("form_fields")
}

// =============================================================================
// MODULE 3: LEADS & DATA MANAGEMENT
// =============================================================================

/// Contact/prospect records captured through workflows
model Lead {
  id                String     @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  workflowId        String     @map("workflow_id") @db.Uuid
  workspaceId       String     @map("workspace_id") @db.Uuid
  email             String     @db.Citext
  name              String?    @db.VarChar(150)
  companyName       String?    @map("company_name") @db.VarChar(150)
  phone             String?    @db.VarChar(50)
  status            LeadStatus @default(NEW)
  source            LeadSource
  sourceMetadata    Json?      @map("source_metadata") @db.JsonB
  score             Int        @default(0)
  tags              String[]
  meetingEventId    String?    @map("meeting_event_id") @db.VarChar(255)
  meetingStatus     String?    @map("meeting_status") @db.VarChar(20) // 'SCHEDULED' | 'ACCEPTED' | 'DECLINED' | 'CANCELLED' | 'COMPLETED'
  enrichmentData    Json?      @map("enrichment_data") @db.JsonB
  enrichmentStatus  EnrichmentStatus? @default(PENDING) @map("enrichment_status")
  enrichedAt        DateTime?  @map("enriched_at") @db.Timestamp()
  lastActivityAt    DateTime?  @map("last_activity_at") @db.Timestamp()
  lastEmailSentAt   DateTime?  @map("last_email_sent_at") @db.Timestamp()
  lastEmailOpenedAt DateTime?  @map("last_email_opened_at") @db.Timestamp()
  deletedAt         DateTime?  @map("deleted_at") @db.Timestamp()
  createdAt         DateTime   @default(now()) @map("created_at") @db.Timestamp()
  updatedAt         DateTime   @updatedAt @map("updated_at") @db.Timestamp()

  // Relations
  workflow           Workflow            @relation(fields: [workflowId], references: [id], onDelete: Cascade)
  workspace          Workspace           @relation(fields: [workspaceId], references: [id], onDelete: Cascade)
  fieldData          LeadFieldData[]
  events             LeadEvent[]
  workflowExecutions WorkflowExecution[]
  bookings           Booking[]
  sentEmails         SentEmail[]
  messages           Message[]
  meetingRecordings  MeetingRecording[]

  @@unique([workflowId, email], map: "leads_unique_email_per_workflow")
  @@index([workflowId, status], map: "idx_leads_workflow") // TODO: Add partial index WHERE deleted_at IS NULL in migration)
  @@index([workspaceId], map: "idx_leads_workspace") // TODO: Add partial index WHERE deleted_at IS NULL in migration)
  @@index([email], map: "idx_leads_email") // TODO: Add partial index WHERE deleted_at IS NULL in migration)
  @@index([status], map: "idx_leads_status") // TODO: Add partial index WHERE deleted_at IS NULL in migration)
  @@index([createdAt(sort: Desc)], map: "idx_leads_created")
  @@index([tags(ops: ArrayOps)], type: Gin, map: "idx_leads_tags")
  @@map("leads")
}

/// Store calendar booking events from Calendly and Cal.com
model Booking {
  id                       String                    @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  workspaceId              String                    @map("workspace_id") @db.Uuid
  leadId                   String                    @map("lead_id") @db.Uuid
  workflowId               String?                   @map("workflow_id") @db.Uuid
  oauthCredentialId        String                    @map("oauth_credential_id") @db.Uuid
  // Provider details
  providerType             OAuthProviderType         @map("provider_type") // 'CALENDLY' | 'CAL_COM'
  providerEventId          String                    @map("provider_event_id") @db.VarChar(255)
  providerEventUri         String?                   @map("provider_event_uri") @db.Text
  // Event details
  eventName                String                    @map("event_name") @db.VarChar(255)
  eventStartTime           DateTime                  @map("event_start_time") @db.Timestamp()
  eventEndTime             DateTime                  @map("event_end_time") @db.Timestamp()
  eventDurationMinutes     Int?                      @map("event_duration_minutes")
  eventTimezone            String?                   @map("event_timezone") @db.VarChar(100)
  // Invitee details
  inviteeEmail             String                    @map("invitee_email") @db.Citext
  inviteeName              String?                   @map("invitee_name") @db.VarChar(200)
  inviteeTimezone          String?                   @map("invitee_timezone") @db.VarChar(100)
  // Status tracking
  bookingStatus            BookingStatus             @default(scheduled) @map("booking_status")
  cancellationReason       String?                   @map("cancellation_reason") @db.Text
  rescheduledFromBookingId String?                   @map("rescheduled_from_booking_id") @db.Uuid
  // Attribution tracking
  attributionMethod        BookingAttributionMethod? @map("attribution_method")
  utmContent               String?                   @map("utm_content") @db.VarChar(255) // For Calendly
  hiddenFieldValue         String?                   @map("hidden_field_value") @db.VarChar(255) // For Cal.com
  // Meeting details
  meetingLocation          String?                   @map("meeting_location") @db.VarChar(255)
  meetingUrl               String?                   @map("meeting_url") @db.Text
  meetingNotes             String?                   @map("meeting_notes") @db.Text
  // Response/answers from booking form
  responses                Json?                     @db.JsonB
  // Webhook/sync metadata
  receivedVia              BookingReceivedVia?       @map("received_via")
  rawPayload               Json?                     @map("raw_payload") @db.JsonB
  // Timestamps
  createdAt                DateTime                  @default(now()) @map("created_at") @db.Timestamp()
  updatedAt                DateTime                  @updatedAt @map("updated_at") @db.Timestamp()
  syncedAt                 DateTime?                 @map("synced_at") @db.Timestamp()

  // Relations
  workspace              Workspace       @relation(fields: [workspaceId], references: [id], onDelete: Cascade)
  lead                   Lead            @relation(fields: [leadId], references: [id], onDelete: Cascade)
  workflow               Workflow?       @relation(fields: [workflowId], references: [id], onDelete: SetNull)
  oauthCredential        OAuthCredential @relation(fields: [oauthCredentialId], references: [id], onDelete: Cascade)
  rescheduledFromBooking Booking?        @relation("BookingReschedule", fields: [rescheduledFromBookingId], references: [id], onDelete: SetNull)
  rescheduledToBookings  Booking[]       @relation("BookingReschedule")

  @@unique([providerEventId, providerType], map: "bookings_unique_provider_event")
  @@index([leadId], map: "idx_bookings_lead")
  @@index([workspaceId], map: "idx_bookings_workspace")
  @@index([providerEventId, providerType], map: "idx_bookings_provider_event")
  @@index([eventStartTime(sort: Desc)], map: "idx_bookings_event_start")
  @@index([bookingStatus], map: "idx_bookings_status")
  @@index([leadId, attributionMethod], map: "idx_bookings_attribution")
  @@map("bookings")
}

/// Track polling jobs for Calendly FREE users
model BookingPollingJob {
  id                String           @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  oauthCredentialId String           @map("oauth_credential_id") @db.Uuid
  // Job execution metadata
  startedAt         DateTime         @default(now()) @map("started_at") @db.Timestamp()
  completedAt       DateTime?        @map("completed_at") @db.Timestamp()
  status            PollingJobStatus @default(RUNNING)
  // Results
  eventsFetched     Int              @default(0) @map("events_fetched")
  eventsCreated     Int              @default(0) @map("events_created")
  eventsUpdated     Int              @default(0) @map("events_updated")
  eventsSkipped     Int              @default(0) @map("events_skipped")
  // Error tracking
  errorMessage      String?          @map("error_message") @db.Text
  errorDetails      Json?            @map("error_details") @db.JsonB
  // Performance metrics
  apiCallsMade      Int              @default(0) @map("api_calls_made")
  durationMs        Int?             @map("duration_ms")

  // Relations
  oauthCredential OAuthCredential @relation(fields: [oauthCredentialId], references: [id], onDelete: Cascade)

  @@index([oauthCredentialId], map: "idx_polling_jobs_credential")
  @@index([status, startedAt(sort: Desc)], map: "idx_polling_jobs_status")
  @@map("booking_polling_jobs")
}

/// Store all automated emails sent through workflows
model SentEmail {
  id                   String    @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  workspaceId          String    @map("workspace_id") @db.Uuid
  leadId               String    @map("lead_id") @db.Uuid
  workflowExecutionId  String    @map("workflow_execution_id") @db.Uuid
  workflowId           String    @map("workflow_id") @db.Uuid
  // Email content
  recipientEmail       String    @map("recipient_email") @db.Citext
  recipientName        String?   @map("recipient_name") @db.VarChar(200)
  senderEmail          String    @map("sender_email") @db.Citext
  senderName           String?   @map("sender_name") @db.VarChar(200)
  subject              String    @db.VarChar(500)
  htmlBody             String    @map("html_body") @db.Text
  textBody             String?   @map("text_body") @db.Text
  // Email metadata
  emailType            String    @map("email_type") @db.VarChar(20) // 'welcome' | 'thank_you' | 'follow_up'
  providerType         String    @map("provider_type") @db.VarChar(20) // 'GMAIL' | 'SMTP'
  gmailMessageId       String?   @map("gmail_message_id") @db.VarChar(255)
  gmailThreadId        String?   @map("gmail_thread_id") @db.VarChar(255)
  smtpMessageId        String?   @map("smtp_message_id") @db.VarChar(255)
  // Delivery tracking
  deliveryStatus       String    @default("sent") @map("delivery_status") @db.VarChar(20) // 'sent' | 'delivered' | 'bounced' | 'failed'
  deliveryError        String?   @map("delivery_error") @db.Text
  // Open tracking
  openCount            Int       @default(0) @map("open_count")
  firstOpenedAt        DateTime? @map("first_opened_at") @db.Timestamp()
  lastOpenedAt         DateTime? @map("last_opened_at") @db.Timestamp()
  // MPP-proof tracking metrics
  genuineOpenCount     Int       @default(0) @map("genuine_open_count")
  botPrefetchCount     Int       @default(0) @map("bot_prefetch_count")
  ambiguousOpenCount   Int       @default(0) @map("ambiguous_open_count")
  directOpenCount      Int       @default(0) @map("direct_open_count")
  // Timestamps
  sentAt               DateTime  @default(now()) @map("sent_at") @db.Timestamp()
  createdAt            DateTime  @default(now()) @map("created_at") @db.Timestamp()
  updatedAt            DateTime  @updatedAt @map("updated_at") @db.Timestamp()

  // Relations
  workspace          Workspace              @relation(fields: [workspaceId], references: [id], onDelete: Cascade)
  lead               Lead                   @relation(fields: [leadId], references: [id], onDelete: Cascade)
  workflowExecution  WorkflowExecution      @relation(fields: [workflowExecutionId], references: [id], onDelete: Cascade)
  workflow           Workflow               @relation(fields: [workflowId], references: [id], onDelete: Cascade)
  trackingEvents     EmailTrackingEvent[]

  @@index([workspaceId, sentAt(sort: Desc)], map: "idx_sent_emails_workspace")
  @@index([leadId, sentAt(sort: Desc)], map: "idx_sent_emails_lead")
  @@index([workflowExecutionId], map: "idx_sent_emails_execution")
  @@index([emailType], map: "idx_sent_emails_type")
  @@index([deliveryStatus], map: "idx_sent_emails_delivery_status")
  @@index([openCount], map: "idx_sent_emails_open_count")
  @@index([gmailMessageId], map: "idx_sent_emails_gmail_message") // TODO: Add partial index WHERE gmail_message_id IS NOT NULL in migration
  @@map("sent_emails")
}

/// Track individual email open events with MPP classification
model EmailTrackingEvent {
  id                   String                       @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  sentEmailId          String                       @map("sent_email_id") @db.Uuid
  workspaceId          String                       @map("workspace_id") @db.Uuid
  // Temporal data
  sentAt               DateTime                     @map("sent_at") @db.Timestamp()
  openedAt             DateTime                     @map("opened_at") @db.Timestamp()
  timeDeltaSeconds     Int                          @map("time_delta_seconds")
  // Infrastructure data
  clientIp             String                       @map("client_ip") @db.VarChar(45)
  resolvedHostname     String?                      @map("resolved_hostname") @db.VarChar(255)
  userAgent            String?                      @map("user_agent") @db.Text
  // Classification
  isAppleProxy         Boolean                      @map("is_apple_proxy")
  classification       EmailTrackingClassification
  // Metadata
  metadata             Json?                        @db.JsonB
  createdAt            DateTime                     @default(now()) @map("created_at") @db.Timestamp()

  // Relations
  sentEmail SentEmail @relation(fields: [sentEmailId], references: [id], onDelete: Cascade)
  workspace Workspace @relation(fields: [workspaceId], references: [id], onDelete: Cascade)

  @@index([sentEmailId, classification], map: "idx_tracking_events_email")
  @@index([workspaceId, openedAt(sort: Desc)], map: "idx_tracking_events_workspace")
  @@index([classification], map: "idx_tracking_events_classification")
  @@index([clientIp], map: "idx_tracking_events_client_ip")
  @@map("email_tracking_events")
}

/// Store inbound and outbound email messages for Gmail Relay system
model Message {
  id          String           @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  workspaceId String           @map("workspace_id") @db.Uuid
  leadId      String           @map("lead_id") @db.Uuid
  direction   MessageDirection
  // Email headers
  fromEmail   String           @map("from_email") @db.Citext
  fromName    String?          @map("from_name") @db.VarChar(200)
  toEmail     String           @map("to_email") @db.Citext
  toName      String?          @map("to_name") @db.VarChar(200)
  subject     String           @db.VarChar(500)
  // Email body
  htmlBody    String?          @map("html_body") @db.Text
  textBody    String           @map("text_body") @db.Text
  // Email metadata
  headers     Json?            @db.JsonB
  inReplyTo   String?          @map("in_reply_to") @db.VarChar(255)
  messageId   String?          @unique @map("message_id") @db.VarChar(255)
  threadId    String?          @map("thread_id") @db.VarChar(255)
  // Timestamps
  sentAt      DateTime?        @map("sent_at") @db.Timestamp()
  receivedAt  DateTime?        @map("received_at") @db.Timestamp()
  createdAt   DateTime         @default(now()) @map("created_at") @db.Timestamp()
  updatedAt   DateTime         @updatedAt @map("updated_at") @db.Timestamp()

  // Relations
  workspace Workspace @relation(fields: [workspaceId], references: [id], onDelete: Cascade)
  lead      Lead      @relation(fields: [leadId], references: [id], onDelete: Cascade)

  @@index([leadId, createdAt(sort: Desc)], map: "idx_messages_lead")
  @@index([workspaceId, direction], map: "idx_messages_workspace")
  @@index([threadId], map: "idx_messages_thread")
  @@index([messageId], map: "idx_messages_message_id")
  @@map("messages")
}

/// Track webhook idempotency to prevent duplicates
model WebhookIdempotencyKey {
  id          String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  key         String   @unique @db.VarChar(255)
  metadata    Json?    @db.JsonB
  processedAt DateTime @default(now()) @map("processed_at") @db.Timestamp()

  @@index([processedAt], map: "idx_webhook_idempotency_processed_at")
  @@map("webhook_idempotency_keys")
}

/// Store failed webhooks for manual review (dead letter queue)
model WebhookDeadLetterQueue {
  id           String            @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  provider     OAuthProviderType
  eventId      String            @map("event_id") @db.VarChar(255)
  eventType    String            @map("event_type") @db.VarChar(100)
  errorMessage String            @map("error_message") @db.Text
  errorStack   String?           @map("error_stack") @db.Text
  retryCount   Int               @default(0) @map("retry_count")
  payload      Json?             @db.JsonB
  status       String            @default("PENDING") @db.VarChar(20) // 'PENDING' | 'RESOLVED' | 'IGNORED'
  resolvedAt   DateTime?         @map("resolved_at") @db.Timestamp()
  failedAt     DateTime          @default(now()) @map("failed_at") @db.Timestamp()

  @@index([status, failedAt(sort: Desc)], map: "idx_webhook_dlq_status")
  @@index([provider, eventId], map: "idx_webhook_dlq_provider_event")
  @@map("webhook_dead_letter_queue")
}

/// Store custom form field responses (EAV pattern)
model LeadFieldData {
  id          String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  leadId      String   @map("lead_id") @db.Uuid
  formFieldId String   @map("form_field_id") @db.Uuid
  value       String   @db.Text
  createdAt   DateTime @default(now()) @map("created_at") @db.Timestamp()
  updatedAt   DateTime @updatedAt @map("updated_at") @db.Timestamp()

  // Relations
  lead      Lead      @relation(fields: [leadId], references: [id], onDelete: Cascade)
  formField FormField @relation(fields: [formFieldId], references: [id], onDelete: Cascade)

  @@unique([leadId, formFieldId], map: "lead_field_data_unique_lead_field")
  @@index([leadId], map: "idx_lead_field_data_lead")
  @@index([formFieldId], map: "idx_lead_field_data_field")
  @@map("lead_field_data")
}

/// Immutable audit trail of all lead activities
model LeadEvent {
  id                             String            @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  leadId                         String            @map("lead_id") @db.Uuid
  eventType                      String            @map("event_type") @db.VarChar(50)
  eventCategory                  LeadEventCategory @default(activity) @map("event_category")
  description                    String?           @db.Text
  metadata                       Json?             @db.JsonB
  triggeredByUserId              String?           @map("triggered_by_user_id") @db.Uuid
  triggeredByWorkflowExecutionId String?           @map("triggered_by_workflow_execution_id") @db.Uuid
  createdAt                      DateTime          @default(now()) @map("created_at") @db.Timestamp()

  // Relations
  lead        Lead  @relation(fields: [leadId], references: [id], onDelete: Cascade)
  triggeredBy User? @relation(fields: [triggeredByUserId], references: [id], onDelete: SetNull)

  @@index([leadId, createdAt(sort: Desc)], map: "idx_lead_events_lead")
  @@index([eventType], map: "idx_lead_events_type")
  @@index([createdAt(sort: Desc)], map: "idx_lead_events_created")
  @@map("lead_events")
}

// =============================================================================
// MODULE 4: EXECUTION ENGINE
// =============================================================================

/// Top-level workflow run tracking
model WorkflowExecution {
  id              String                  @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  workflowId      String                  @map("workflow_id") @db.Uuid
  workspaceId     String                  @map("workspace_id") @db.Uuid
  leadId          String?                 @map("lead_id") @db.Uuid
  executionNumber BigInt                  @default(autoincrement()) @map("execution_number")
  idempotencyKey  String?                 @map("idempotency_key") @db.VarChar(255)
  triggerType     String                  @map("trigger_type") @db.VarChar(50)
  triggerNodeId   String?                 @map("trigger_node_id") @db.Uuid
  triggerData     Json?                   @map("trigger_data") @db.JsonB
  status          WorkflowExecutionStatus @default(running)
  startedAt       DateTime?               @map("started_at") @db.Timestamp()
  completedAt     DateTime?               @map("completed_at") @db.Timestamp()
  durationMs      Int?                    @map("duration_ms")
  errorMessage    String?                 @map("error_message") @db.Text
  errorDetails    Json?                   @map("error_details") @db.JsonB
  retryCount      Int                     @default(0) @map("retry_count")
  maxRetries      Int                     @default(3) @map("max_retries")
  lockAcquiredAt  DateTime?               @map("lock_acquired_at") @db.Timestamp()
  lockReleasedAt  DateTime?               @map("lock_released_at") @db.Timestamp()
  outputData      Json?                   @map("output_data") @db.JsonB
  createdAt       DateTime                @default(now()) @map("created_at") @db.Timestamp()
  updatedAt       DateTime                @updatedAt @map("updated_at") @db.Timestamp()

  // Relations
  workflow          Workflow           @relation(fields: [workflowId], references: [id], onDelete: Cascade)
  workspace         Workspace          @relation(fields: [workspaceId], references: [id], onDelete: Cascade)
  lead              Lead?              @relation(fields: [leadId], references: [id], onDelete: SetNull)
  triggerNode       WorkflowNode?      @relation(fields: [triggerNodeId], references: [id], onDelete: SetNull)
  executionSteps    ExecutionStep[]
  executionLogs     ExecutionLog[]
  sentEmails        SentEmail[]
  meetingRecordings MeetingRecording[]

  @@unique([workflowId, idempotencyKey], map: "workflow_executions_unique_idempotency")
  @@index([workflowId, status, createdAt(sort: Desc)], map: "idx_workflow_executions_workflow")
  @@index([workspaceId, createdAt(sort: Desc)], map: "idx_workflow_executions_workspace")
  @@index([leadId], map: "idx_workflow_executions_lead") // TODO: Add partial index WHERE lead_id IS NOT NULL in migration)
  @@index([status], map: "idx_workflow_executions_status") // TODO: Add partial index WHERE status IN ('queued', 'running') in migration)
  @@index([idempotencyKey], map: "idx_workflow_executions_idempotency") // TODO: Add partial index WHERE idempotency_key IS NOT NULL in migration)
  @@index([createdAt(sort: Desc)], map: "idx_workflow_executions_created")
  @@map("workflow_executions")
}

/// Daily aggregated analytics for workflow form performance
model WorkflowDailyStat {
  id              String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  workflowId      String   @map("workflow_id") @db.Uuid
  workspaceId     String   @map("workspace_id") @db.Uuid
  statDate        DateTime @map("stat_date") @db.Date
  formViews       Int      @default(0) @map("form_views")
  formSubmissions Int      @default(0) @map("form_submissions")
  conversionRate  Decimal? @map("conversion_rate") @db.Decimal(5, 2)
  topLeadSources  Json?    @map("top_lead_sources") @db.JsonB
  createdAt       DateTime @default(now()) @map("created_at") @db.Timestamp()

  // Relations
  workflow  Workflow  @relation(fields: [workflowId], references: [id], onDelete: Cascade)
  workspace Workspace @relation(fields: [workspaceId], references: [id], onDelete: Cascade)

  @@unique([workflowId, statDate], map: "workflow_daily_stats_unique_workflow_date")
  @@index([workflowId, statDate(sort: Desc)], map: "idx_workflow_daily_stats_workflow")
  @@index([workspaceId, statDate(sort: Desc)], map: "idx_workflow_daily_stats_workspace")
  @@index([statDate(sort: Desc)], map: "idx_workflow_daily_stats_date")
  @@map("workflow_daily_stats")
}

/// Individual node executions within a workflow run
model ExecutionStep {
  id             String              @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  executionId    String              @map("execution_id") @db.Uuid
  workflowNodeId String              @map("workflow_node_id") @db.Uuid
  stepNumber     Int                 @map("step_number")
  status         ExecutionStepStatus @default(pending)
  startedAt      DateTime?           @map("started_at") @db.Timestamp()
  completedAt    DateTime?           @map("completed_at") @db.Timestamp()
  durationMs     Int?                @map("duration_ms")
  inputData      Json?               @map("input_data") @db.JsonB
  outputData     Json?               @map("output_data") @db.JsonB
  errorMessage   String?             @map("error_message") @db.Text
  errorDetails   Json?               @map("error_details") @db.JsonB
  retryCount     Int                 @default(0) @map("retry_count")
  createdAt      DateTime            @default(now()) @map("created_at") @db.Timestamp()
  updatedAt      DateTime            @updatedAt @map("updated_at") @db.Timestamp()

  // Relations
  execution    WorkflowExecution @relation(fields: [executionId], references: [id], onDelete: Cascade)
  workflowNode WorkflowNode      @relation(fields: [workflowNodeId], references: [id], onDelete: Cascade)

  @@index([executionId, stepNumber], map: "idx_execution_steps_execution")
  @@index([workflowNodeId], map: "idx_execution_steps_node")
  @@index([status], map: "idx_execution_steps_status") // TODO: Add partial index WHERE status = 'running' in migration)
  @@map("execution_steps")
}

// NOTE: This table requires manual partitioning via raw SQL migration
// Partition by RANGE (created_at) - see migration file for implementation
/// High-volume detailed logging for workflow executions (PARTITIONED)
model ExecutionLog {
  id              String   @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  executionId     String   @map("execution_id") @db.Uuid
  executionStepId String?  @map("execution_step_id") @db.Uuid
  workspaceId     String   @map("workspace_id") @db.Uuid
  logLevel        LogLevel @map("log_level")
  logCategory     String?  @map("log_category") @db.VarChar(50)
  message         String   @db.Text
  details         Json?    @db.JsonB
  nodeType        String?  @map("node_type") @db.VarChar(50)
  createdAt       DateTime @default(now()) @map("created_at") @db.Timestamp()

  // Relations
  execution WorkflowExecution @relation(fields: [executionId], references: [id], onDelete: Cascade)

  @@id([id, createdAt])
  @@index([executionId, createdAt(sort: Desc)], map: "idx_execution_logs_execution")
  @@index([workspaceId, createdAt(sort: Desc)], map: "idx_execution_logs_workspace")
  @@index([logLevel], map: "idx_execution_logs_level") // TODO: Add partial index WHERE log_level IN ('ERROR', 'WARN') in migration)
  @@index([logCategory], map: "idx_execution_logs_category")
  @@map("execution_logs")
}

// =============================================================================
// MODULE 5: BILLING & USAGE TRACKING
// =============================================================================

/// Define product tiers and pricing
model SubscriptionPlan {
  id                 String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  name               String   @unique @db.VarChar(100)
  slug               String   @unique @db.VarChar(50)
  description        String?  @db.Text
  priceMonthllyCents Int?     @map("price_monthly_cents")
  priceYearlyCents   Int?     @map("price_yearly_cents")
  currency           String   @default("USD") @db.VarChar(3)
  quotas             Json     @db.JsonB
  features           Json?    @db.JsonB
  displayOrder       Int      @default(0) @map("display_order")
  isActive           Boolean  @default(true) @map("is_active")
  isVisible          Boolean  @default(true) @map("is_visible")
  createdAt          DateTime @default(now()) @map("created_at") @db.Timestamp()
  updatedAt          DateTime @updatedAt @map("updated_at") @db.Timestamp()

  // Relations
  subscriptions Subscription[]

  @@index([isActive, displayOrder], map: "idx_subscription_plans_active")
  @@map("subscription_plans")
}

/// Workspace subscription tracking
model Subscription {
  id                   String             @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  workspaceId          String             @map("workspace_id") @db.Uuid
  subscriptionPlanId   String             @map("subscription_plan_id") @db.Uuid
  stripeSubscriptionId String?            @unique @map("stripe_subscription_id") @db.VarChar(255)
  stripeCustomerId     String?            @map("stripe_customer_id") @db.VarChar(255)
  status               SubscriptionStatus @default(active)
  billingCycle         BillingCycle       @map("billing_cycle")
  trialStartDate       DateTime?          @map("trial_start_date") @db.Date
  trialEndDate         DateTime?          @map("trial_end_date") @db.Date
  currentPeriodStart   DateTime           @map("current_period_start") @db.Date
  currentPeriodEnd     DateTime           @map("current_period_end") @db.Date
  cancelAtPeriodEnd    Boolean            @default(false) @map("cancel_at_period_end")
  cancelledAt          DateTime?          @map("cancelled_at") @db.Timestamp()
  metadata             Json?              @db.JsonB
  createdAt            DateTime           @default(now()) @map("created_at") @db.Timestamp()
  updatedAt            DateTime           @updatedAt @map("updated_at") @db.Timestamp()

  // Relations
  workspace        Workspace        @relation(fields: [workspaceId], references: [id], onDelete: Cascade)
  subscriptionPlan SubscriptionPlan @relation(fields: [subscriptionPlanId], references: [id], onDelete: Restrict)

  @@index([workspaceId], map: "idx_subscriptions_workspace")
  @@index([status], map: "idx_subscriptions_status") // TODO: Add partial index WHERE status = 'active' in migration)
  @@index([stripeSubscriptionId], map: "idx_subscriptions_stripe") // TODO: Add partial index WHERE stripe_subscription_id IS NOT NULL in migration)
  @@map("subscriptions")
}

/// Current billing period usage tracking
model UsageQuota {
  id          String    @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  workspaceId String    @map("workspace_id") @db.Uuid
  quotaKey    String    @map("quota_key") @db.VarChar(50)
  quotaLimit  Int       @map("quota_limit")
  quotaUsed   Int       @default(0) @map("quota_used")
  periodStart DateTime  @map("period_start") @db.Date
  periodEnd   DateTime  @map("period_end") @db.Date
  lastResetAt DateTime? @map("last_reset_at") @db.Timestamp()
  createdAt   DateTime  @default(now()) @map("created_at") @db.Timestamp()
  updatedAt   DateTime  @updatedAt @map("updated_at") @db.Timestamp()

  // Relations
  workspace Workspace @relation(fields: [workspaceId], references: [id], onDelete: Cascade)

  @@unique([workspaceId, quotaKey, periodStart], map: "usage_quotas_unique_workspace_key_period")
  @@index([workspaceId, quotaKey], map: "idx_usage_quotas_workspace")
  @@index([periodStart, periodEnd], map: "idx_usage_quotas_period")
  @@map("usage_quotas")
}

/// Detailed usage event log for billing
model UsageEvent {
  id                  String             @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  workspaceId         String             @map("workspace_id") @db.Uuid
  eventType           String             @map("event_type") @db.VarChar(50)
  eventCategory       UsageEventCategory @map("event_category")
  quantity            Int                @default(1)
  relatedResourceId   String?            @map("related_resource_id") @db.Uuid
  relatedResourceType String?            @map("related_resource_type") @db.VarChar(50)
  isBillable          Boolean            @default(true) @map("is_billable")
  billedAt            DateTime?          @map("billed_at") @db.Timestamp()
  metadata            Json?              @db.JsonB
  createdAt           DateTime           @default(now()) @map("created_at") @db.Timestamp()

  // Relations
  workspace Workspace @relation(fields: [workspaceId], references: [id], onDelete: Cascade)

  @@index([workspaceId, createdAt(sort: Desc)], map: "idx_usage_events_workspace")
  @@index([eventType], map: "idx_usage_events_type")
  @@index([isBillable, billedAt], map: "idx_usage_events_billable") // TODO: Add partial index WHERE is_billable = true in migration)
  @@index([createdAt(sort: Desc)], map: "idx_usage_events_created")
  @@map("usage_events")
}

// =============================================================================
// MODULE 6: WEBHOOKS & INTEGRATIONS
// =============================================================================

/// Outgoing webhook configuration
model WebhookEndpoint {
  id                String    @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  workspaceId       String    @map("workspace_id") @db.Uuid
  url               String    @db.Text
  description       String?   @db.VarChar(255)
  secretKey         String?   @map("secret_key") @db.VarChar(255)
  authHeaderName    String?   @map("auth_header_name") @db.VarChar(100)
  authHeaderValue   String?   @map("auth_header_value") @db.Text
  subscribedEvents  String[]  @map("subscribed_events")
  maxRetries        Int       @default(3) @map("max_retries")
  retryDelaySeconds Int       @default(60) @map("retry_delay_seconds")
  isActive          Boolean   @default(true) @map("is_active")
  lastTriggeredAt   DateTime? @map("last_triggered_at") @db.Timestamp()
  deletedAt         DateTime? @map("deleted_at") @db.Timestamp()
  createdAt         DateTime  @default(now()) @map("created_at") @db.Timestamp()
  updatedAt         DateTime  @updatedAt @map("updated_at") @db.Timestamp()

  // Relations
  workspace         Workspace         @relation(fields: [workspaceId], references: [id], onDelete: Cascade)
  webhookDeliveries WebhookDelivery[]

  @@index([workspaceId], map: "idx_webhook_endpoints_workspace") // TODO: Add partial index WHERE deleted_at IS NULL in migration)
  @@index([isActive], map: "idx_webhook_endpoints_active") // TODO: Add partial index WHERE is_active = true in migration)
  @@map("webhook_endpoints")
}

/// Webhook delivery tracking
model WebhookDelivery {
  id                String                @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  webhookEndpointId String                @map("webhook_endpoint_id") @db.Uuid
  eventType         String                @map("event_type") @db.VarChar(50)
  payload           Json                  @db.JsonB
  httpStatusCode    Int?                  @map("http_status_code")
  requestHeaders    Json?                 @map("request_headers") @db.JsonB
  responseBody      String?               @map("response_body") @db.Text
  responseHeaders   Json?                 @map("response_headers") @db.JsonB
  status            WebhookDeliveryStatus @default(pending)
  attemptNumber     Int                   @default(1) @map("attempt_number")
  maxAttempts       Int                   @default(3) @map("max_attempts")
  nextRetryAt       DateTime?             @map("next_retry_at") @db.Timestamp()
  deliveredAt       DateTime?             @map("delivered_at") @db.Timestamp()
  durationMs        Int?                  @map("duration_ms")
  errorMessage      String?               @map("error_message") @db.Text
  createdAt         DateTime              @default(now()) @map("created_at") @db.Timestamp()
  updatedAt         DateTime              @updatedAt @map("updated_at") @db.Timestamp()

  // Relations
  webhookEndpoint WebhookEndpoint @relation(fields: [webhookEndpointId], references: [id], onDelete: Cascade)

  @@index([webhookEndpointId, createdAt(sort: Desc)], map: "idx_webhook_deliveries_endpoint")
  @@index([status], map: "idx_webhook_deliveries_status") // TODO: Add partial index WHERE status IN ('pending', 'failed') in migration
  @@index([nextRetryAt], map: "idx_webhook_deliveries_retry") // TODO: Add partial index WHERE status = 'failed' in migration
  @@map("webhook_deliveries")
}

// =============================================================================
// MODULE 6B: AUTHENTICATION TOKENS
// =============================================================================

/// Password reset tokens for native authentication
model PasswordResetToken {
  id        String    @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  userId    String    @map("user_id") @db.Uuid
  token     String    @unique @db.VarChar(255)
  expiresAt DateTime  @map("expires_at") @db.Timestamp()
  isUsed    Boolean   @default(false) @map("is_used")
  usedAt    DateTime? @map("used_at") @db.Timestamp()
  createdAt DateTime  @default(now()) @map("created_at") @db.Timestamp()

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([token], map: "idx_password_reset_token")
  @@index([userId, expiresAt], map: "idx_password_reset_user_expiry")
  @@index([createdAt], map: "idx_password_reset_created")
  @@map("password_reset_tokens")
}

/// Refresh tokens for JWT authentication with rotation support
model RefreshToken {
  id        String    @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  userId    String    @map("user_id") @db.Uuid
  token     String    @unique @db.Text
  expiresAt DateTime  @map("expires_at") @db.Timestamp()
  isRevoked Boolean   @default(false) @map("is_revoked")
  revokedAt DateTime? @map("revoked_at") @db.Timestamp()
  userAgent String?   @map("user_agent") @db.Text
  ipAddress String?   @map("ip_address") @db.VarChar(45)
  createdAt DateTime  @default(now()) @map("created_at") @db.Timestamp()

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([token], map: "idx_refresh_token")
  @@index([userId, isRevoked], map: "idx_refresh_user")
  @@index([expiresAt], map: "idx_refresh_expiry")
  @@map("refresh_tokens")
}

/// Login attempt tracking for security and rate limiting
model LoginAttempt {
  id            String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  email         String   @db.Citext
  ipAddress     String   @map("ip_address") @db.VarChar(45)
  userAgent     String?  @map("user_agent") @db.Text
  wasSuccessful Boolean  @default(false) @map("was_successful")
  failureReason String?  @map("failure_reason") @db.VarChar(100)
  createdAt     DateTime @default(now()) @map("created_at") @db.Timestamp()

  @@index([email, createdAt(sort: Desc)], map: "idx_login_attempts_email")
  @@index([ipAddress, createdAt(sort: Desc)], map: "idx_login_attempts_ip")
  @@index([createdAt], map: "idx_login_attempts_created")
  @@map("login_attempts")
}

// =============================================================================
// MODULE 7: ANALYTICS & REPORTING
// =============================================================================

/// Pre-aggregated daily metrics
model WorkspaceDailyStat {
  id                     String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  workspaceId            String   @map("workspace_id") @db.Uuid
  statDate               DateTime @map("stat_date") @db.Date
  leadsCreated           Int      @default(0) @map("leads_created")
  leadsQualified         Int      @default(0) @map("leads_qualified")
  leadsWon               Int      @default(0) @map("leads_won")
  totalExecutions        Int      @default(0) @map("total_executions")
  successfulExecutions   Int      @default(0) @map("successful_executions")
  failedExecutions       Int      @default(0) @map("failed_executions")
  emailsSent             Int      @default(0) @map("emails_sent")
  emailsOpened           Int      @default(0) @map("emails_opened")
  emailsClicked          Int      @default(0) @map("emails_clicked")
  avgExecutionDurationMs Int?     @map("avg_execution_duration_ms")
  createdAt              DateTime @default(now()) @map("created_at") @db.Timestamp()

  // Relations
  workspace Workspace @relation(fields: [workspaceId], references: [id], onDelete: Cascade)

  @@unique([workspaceId, statDate], map: "workspace_daily_stats_unique_workspace_date")
  @@index([workspaceId, statDate(sort: Desc)], map: "idx_workspace_daily_stats_workspace")
  @@index([statDate(sort: Desc)], map: "idx_workspace_daily_stats_date")
  @@map("workspace_daily_stats")
}

// =============================================================================
// MODULE 8: ONBOARDING
// =============================================================================

/// Track user onboarding progress through 4-step automation setup
model OnboardingSession {
  id                 String    @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  userId             String    @map("user_id") @db.Uuid
  workspaceId        String    @map("workspace_id") @db.Uuid
  currentStep        Int       @default(1) @map("current_step")
  completedSteps     Int[]     @map("completed_steps")
  selectedStrategyId String?   @map("selected_strategy_id") @db.VarChar(100)
  templateId         String?   @map("template_id") @db.VarChar(100)
  configurationData  Json?     @map("configuration_data") @db.JsonB
  isComplete         Boolean   @default(false) @map("is_complete")
  completedAt        DateTime? @map("completed_at") @db.Timestamp()
  createdAt          DateTime  @default(now()) @map("created_at") @db.Timestamp()
  updatedAt          DateTime  @updatedAt @map("updated_at") @db.Timestamp()

  // Relations
  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  workspace Workspace @relation(fields: [workspaceId], references: [id], onDelete: Cascade)

  @@unique([userId, workspaceId], map: "onboarding_sessions_unique_user_workspace")
  @@index([userId], map: "idx_onboarding_sessions_user")
  @@index([workspaceId], map: "idx_onboarding_sessions_workspace")
  @@index([isComplete], map: "idx_onboarding_sessions_complete")
  @@map("onboarding_sessions")
}

// =============================================================================
// MODULE 9: MEETING RECORDER
// =============================================================================

enum RecordingStatus {
  RECORDING
  PROCESSING
  COMPLETED
  FAILED

  @@map("recording_status")
}

enum SpeakerType {
  HOST
  GUEST
  UNKNOWN

  @@map("speaker_type")
}

/// Store meeting recordings with audio files and metadata
model MeetingRecording {
  id                    String           @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  workspaceId           String           @map("workspace_id") @db.Uuid
  leadId                String?          @map("lead_id") @db.Uuid
  workflowExecutionId   String?          @map("workflow_execution_id") @db.Uuid
  // Meeting metadata
  meetingTitle          String?          @map("meeting_title") @db.VarChar(255)
  meetingPlatform       String           @map("meeting_platform") @db.VarChar(20) // 'GOOGLE_MEET' | 'ZOOM' | 'TEAMS' | 'UNKNOWN'
  meetingUrl            String?          @map("meeting_url") @db.Text
  // Recording status
  recordingStatus       RecordingStatus  @default(RECORDING) @map("recording_status")
  // File storage paths (relative to storage directory)
  stereoAudioPath       String?          @map("stereo_audio_path") @db.Text
  monoAudioPath         String?          @map("mono_audio_path") @db.Text // Echo-reduced mono audio (new pipeline)
  hostAudioPath         String?          @map("host_audio_path") @db.Text
  guestAudioPath        String?          @map("guest_audio_path") @db.Text
  eventsLogPath         String?          @map("events_log_path") @db.Text
  // Timestamps
  recordingStartedAt    DateTime         @map("recording_started_at") @db.Timestamp()
  recordingEndedAt      DateTime?        @map("recording_ended_at") @db.Timestamp()
  processingStartedAt   DateTime?        @map("processing_started_at") @db.Timestamp()
  processingCompletedAt DateTime?        @map("processing_completed_at") @db.Timestamp()
  // Statistics
  durationSeconds       Int?             @map("duration_seconds")
  fileSizeBytes         BigInt?          @map("file_size_bytes")
  // Error tracking
  errorMessage          String?          @map("error_message") @db.Text
  errorDetails          Json?            @map("error_details") @db.JsonB
  // Metadata
  metadata              Json?            @db.JsonB
  createdAt             DateTime         @default(now()) @map("created_at") @db.Timestamp()
  updatedAt             DateTime         @updatedAt @map("updated_at") @db.Timestamp()

  // Relations
  workspace          Workspace          @relation(fields: [workspaceId], references: [id], onDelete: Cascade)
  lead               Lead?              @relation(fields: [leadId], references: [id], onDelete: SetNull)
  workflowExecution  WorkflowExecution? @relation(fields: [workflowExecutionId], references: [id], onDelete: SetNull)
  transcriptSegments TranscriptSegment[]
  meetingSummary     MeetingSummary?

  @@index([workspaceId, recordingStatus], map: "idx_meeting_recordings_workspace")
  @@index([leadId], map: "idx_meeting_recordings_lead")
  @@index([recordingStartedAt(sort: Desc)], map: "idx_meeting_recordings_started")
  @@index([recordingStatus], map: "idx_meeting_recordings_status")
  @@map("meeting_recordings")
}

/// Store individual transcript segments with speaker information
model TranscriptSegment {
  id                 String           @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  meetingRecordingId String           @map("meeting_recording_id") @db.Uuid
  // Speaker information
  speakerName        String           @map("speaker_name") @db.VarChar(150)
  speakerType        SpeakerType      @map("speaker_type")
  // Transcript content
  text               String           @db.Text
  // Timing (milliseconds)
  startTimeMs        Int              @map("start_time_ms")
  endTimeMs          Int              @map("end_time_ms")
  // Confidence metrics
  confidence         Decimal?         @db.Decimal(5, 4)
  audioSource        String           @map("audio_source") @db.VarChar(20) // 'HOST_CHANNEL' | 'GUEST_CHANNEL'
  // Metadata
  metadata           Json?            @db.JsonB
  createdAt          DateTime         @default(now()) @map("created_at") @db.Timestamp()

  // Relations
  meetingRecording MeetingRecording @relation(fields: [meetingRecordingId], references: [id], onDelete: Cascade)

  @@index([meetingRecordingId, startTimeMs], map: "idx_transcript_segments_meeting")
  @@index([speakerName], map: "idx_transcript_segments_speaker")
  @@map("transcript_segments")
}

/// Store AI-generated meeting summaries
model MeetingSummary {
  id                   String           @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  meetingRecordingId   String           @unique @map("meeting_recording_id") @db.Uuid
  // Summary content
  summaryText          String           @map("summary_text") @db.Text
  keyDecisions         Json?            @map("key_decisions") @db.JsonB
  actionItems          Json?            @map("action_items") @db.JsonB
  participants         String[]
  topics               String[]
  // Generation metadata
  generatedBy          String           @map("generated_by") @db.VarChar(50) // 'OLLAMA_LLAMA3' | 'GPT4' etc
  generationDurationMs Int?             @map("generation_duration_ms")
  promptTokens         Int?             @map("prompt_tokens")
  completionTokens     Int?             @map("completion_tokens")
  // Timestamps
  createdAt            DateTime         @default(now()) @map("created_at") @db.Timestamp()
  updatedAt            DateTime         @updatedAt @map("updated_at") @db.Timestamp()

  // Relations
  meetingRecording MeetingRecording @relation(fields: [meetingRecordingId], references: [id], onDelete: Cascade)

  @@index([meetingRecordingId], map: "idx_meeting_summaries_recording")
  @@map("meeting_summaries")
}
